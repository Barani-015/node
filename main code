/**
 * Single-file Node.js backend demonstrating:
 * - CRUD for "items"
 * - password hashing (bcrypt)
 * - authentication (JWT)
 * - file uploads (multer)
 * - simple JSON-file persistence (db.json)
 *
 * Usage:
 * 1. npm init -y
 * 2. npm i express bcrypt jsonwebtoken multer uuid fs-extra cors
 * 3. node server.js
 *
 * Defaults:
 * - JWT secret uses process.env.JWT_SECRET or a fallback (change for production!)
 * - Uploads are stored in ./uploads (created automatically)
 * - DB file is ./db.json (created automatically)
 *
 * Endpoints:
 * - POST /auth/register { username, password } -> register
 * - POST /auth/login { username, password } -> returns { token }
 * - GET /items -> public read of items
 * - GET /items/:id -> public read single item
 * - POST /items (protected) -> multipart/form-data: title, description, file
 * - PUT /items/:id (protected)-> update title/description (and optionally replace file)
 * - DELETE /items/:id (protected)
 * - GET /me (protected) -> current user info
 *
 * Protected routes require: Authorization: Bearer <token>
 */

const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const multer = require('multer');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs-extra');
const path = require('path');
const cors = require('cors');

const PORT = process.env.PORT || 4000;
const JWT_SECRET = process.env.JWT_SECRET || 'change_this_secret_for_prod';
const JWT_EXPIRES_IN = '4h';
const DB_FILE = path.resolve(__dirname, 'db.json');
const UPLOAD_DIR = path.resolve(__dirname, 'uploads');
const SALT_ROUNDS = 10;

fs.ensureDirSync(UPLOAD_DIR);

// --- Simple file-backed DB helpers ---
function loadDB() {
  try {
    if (!fs.existsSync(DB_FILE)) {
      const initial = { users: [], items: [] };
      fs.writeJsonSync(DB_FILE, initial, { spaces: 2 });
      return initial;
    }
    return fs.readJsonSync(DB_FILE);
  } catch (err) {
    console.error('Failed to read DB file, resetting:', err);
    const initial = { users: [], items: [] };
    fs.writeJsonSync(DB_FILE, initial, { spaces: 2 });
    return initial;
  }
}

function saveDB(db) {
  fs.writeJsonSync(DB_FILE, db, { spaces: 2 });
}

// Initialize DB
let db = loadDB();

// If no users exist, create a demo admin user
if (db.users.length === 0) {
  (async () => {
    const pw = 'admin123';
    const hash = await bcrypt.hash(pw, SALT_ROUNDS);
    const admin = { id: uuidv4(), username: 'admin', passwordHash: hash, isAdmin: true, createdAt: new Date().toISOString() };
    db.users.push(admin);
    saveDB(db);
    console.log('Created demo admin user -> username: admin password:', pw);
  })();
}

// --- Multer setup ---
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, UPLOAD_DIR);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname) || '';
    cb(null, `${Date.now()}-${uuidv4()}${ext}`);
  }
});
const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5 MB
  fileFilter: (req, file, cb) => {
    // allow common types; adjust as needed
    const allowed = /jpeg|jpg|png|gif|pdf|txt|docx/;
    const ext = path.extname(file.originalname).toLowerCase();
    if (allowed.test(ext)) return cb(null, true);
    cb(new Error('Only images, PDFs, text and docx are allowed'));
  }
});

// --- Express app ---
const app = express();
app.use(cors());
app.use(express.json());
app.use('/uploads', express.static(UPLOAD_DIR)); // serve uploaded files

// --- Auth helpers ---
function signToken(payload) {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });
}

function authMiddleware(req, res, next) {
  const header = req.headers.authorization;
  if (!header || !header.startsWith('Bearer ')) return res.status(401).json({ error: 'Missing Authorization header' });
  const token = header.split(' ')[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    // attach user object (without passwordHash) to request
    const user = db.users.find(u => u.id === payload.id);
    if (!user) return res.status(401).json({ error: 'User not found' });
    req.user = { id: user.id, username: user.username, isAdmin: !!user.isAdmin };
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid or expired token' });
  }
}

// --- Routes ---

// Health
app.get('/', (req, res) => {
  res.json({ ok: true, msg: 'Single-file Node.js backend running' });
});

// Register
app.post('/auth/register', async (req, res) => {
  try {
    const { username, password } = req.body || {};
    if (!username || !password) return res.status(400).json({ error: 'username and password required' });

    const exists = db.users.find(u => u.username.toLowerCase() === username.toLowerCase());
    if (exists) return res.status(400).json({ error: 'username already taken' });

    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
    const newUser = { id: uuidv4(), username, passwordHash, isAdmin: false, createdAt: new Date().toISOString() };
    db.users.push(newUser);
    saveDB(db);

    const token = signToken({ id: newUser.id, username: newUser.username });
    res.status(201).json({ id: newUser.id, username: newUser.username, token });
  } catch (err) {
    console.error('Register error', err);
    res.status(500).json({ error: 'server_error' });
  }
});

// Login
app.post('/auth/login', async (req, res) => {
  try {
    const { username, password } = req.body || {};
    if (!username || !password) return res.status(400).json({ error: 'username and password required' });

    const user = db.users.find(u => u.username.toLowerCase() === username.toLowerCase());
    if (!user) return res.status(400).json({ error: 'invalid credentials' });

    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(400).json({ error: 'invalid credentials' });

    const token = signToken({ id: user.id, username: user.username });
    res.json({ token });
  } catch (err) {
    console.error('Login error', err);
    res.status(500).json({ error: 'server_error' });
  }
});

// Whoami
app.get('/me', authMiddleware, (req, res) => {
  res.json({ user: req.user });
});

// --- Items CRUD ---

// List items (public)
app.get('/items', (req, res) => {
  const items = db.items.map(i => ({ ...i }));
  res.json(items);
});

// Get single item
app.get('/items/:id', (req, res) => {
  const id = req.params.id;
  const item = db.items.find(it => it.id === id);
  if (!item) return res.status(404).json({ error: 'not_found' });
  res.json(item);
});

// Create item (protected) - supports file upload named 'file'
app.post('/items', authMiddleware, upload.single('file'), (req, res) => {
  try {
    const { title, description } = req.body || {};
    if (!title) return res.status(400).json({ error: 'title required' });

    const fileInfo = req.file ? {
      originalname: req.file.originalname,
      filename: req.file.filename,
      path: `/uploads/${req.file.filename}`,
      size: req.file.size,
      mime: req.file.mimetype,
    } : null;

    const item = {
      id: uuidv4(),
      title,
      description: description || '',
      ownerId: req.user.id,
      ownerUsername: req.user.username,
      file: fileInfo,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    db.items.push(item);
    saveDB(db);
    res.status(201).json(item);
  } catch (err) {
    console.error('Create item error', err);
    res.status(500).json({ error: 'server_error' });
  }
});

// Update item (protected) - supports optional new file upload 'file'
app.put('/items/:id', authMiddleware, upload.single('file'), (req, res) => {
  try {
    const id = req.params.id;
    const item = db.items.find(it => it.id === id);
    if (!item) return res.status(404).json({ error: 'not_found' });

    // Only owner or admin can modify
    if (item.ownerId !== req.user.id && !req.user.isAdmin) {
      return res.status(403).json({ error: 'forbidden' });
    }

    const { title, description } = req.body || {};
    if (title) item.title = title;
    if (typeof description !== 'undefined') item.description = description;

    if (req.file) {
      // remove old file if present
      if (item.file && item.file.filename) {
        try { fs.removeSync(path.join(UPLOAD_DIR, item.file.filename)); } catch (e) { /* ignore */ }
      }
      item.file = {
        originalname: req.file.originalname,
        filename: req.file.filename,
        path: `/uploads/${req.file.filename}`,
        size: req.file.size,
        mime: req.file.mimetype,
      };
    }

    item.updatedAt = new Date().toISOString();
    saveDB(db);
    res.json(item);
  } catch (err) {
    console.error('Update item error', err);
    res.status(500).json({ error: 'server_error' });
  }
});

// Delete item (protected)
app.delete('/items/:id', authMiddleware, (req, res) => {
  try {
    const id = req.params.id;
    const idx = db.items.findIndex(it => it.id === id);
    if (idx === -1) return res.status(404).json({ error: 'not_found' });
    const item = db.items[idx];

    // Only owner or admin can delete
    if (item.ownerId !== req.user.id && !req.user.isAdmin) {
      return res.status(403).json({ error: 'forbidden' });
    }

    // remove attached file
    if (item.file && item.file.filename) {
      try { fs.removeSync(path.join(UPLOAD_DIR, item.file.filename)); } catch (e) { /* ignore */ }
    }

    db.items.splice(idx, 1);
    saveDB(db);
    res.json({ ok: true });
  } catch (err) {
    console.error('Delete item error', err);
    res.status(500).json({ error: 'server_error' });
  }
});

// --- Admin-only example: list users ---
app.get('/admin/users', authMiddleware, (req, res) => {
  if (!req.user.isAdmin) return res.status(403).json({ error: 'forbidden' });
  const users = db.users.map(u => ({ id: u.id, username: u.username, isAdmin: !!u.isAdmin, createdAt: u.createdAt }));
  res.json(users);
});

// --- Generic error handler for multer fileFilter errors etc. ---
app.use((err, req, res, next) => {
  if (err && err instanceof multer.MulterError) {
    return res.status(400).json({ error: 'file_upload_error', message: err.message });
  }
  if (err && err.message && err.message.includes('Only images')) {
    return res.status(400).json({ error: 'file_type_not_allowed', message: err.message });
  }
  console.error('Unhandled error:', err);
  res.status(500).json({ error: 'server_error' });
});

// Start server
app.listen(PORT, () => {
  console.log(`Server listening on http://localhost:${PORT}`);
  console.log(`Uploads served at /uploads`);
});
